<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>C++ metaprogramming: evolution and future directions</title>
        <meta name="author" content="Louis Dionne">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/league.css" id="theme">
        <link rel="stylesheet" href="css/custom.css">

        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>

    <body>
        <div class="reveal">
            <div class="slides">
                <section data-markdown=""
                         data-separator="^====+$"
                         data-separator-vertical="^----+$"
                         data-notes="^Note:">
                <script type="text/template">

## C++ metaprogramming: evolution and future directions
### Louis Dionne, Meeting C++ 2016

==============================================================================

## Part 1
## A bit of history

Note:
Discuss Loki, MPL and Fusion
Spend 30 minutes here

====================

The original purpose of templates was to allow writing generic algorithms and
containers for the standard library.

The standard Committee suspected that templates were hiding something more
powerful, but it was not clear.

====================

In 1994, at the San Diego meeting, Erwin Unruh came up with a program that
would print prime numbers at compile-time.

This proved that templates could be used to perform arbitrary computations
inside at compile-time. In other words, C++ contained a Turing complete
sub-language that could be executed inside the compiler. The result of
a program written in that language is another C++ program.

----

### This is the program
#### source: http://www.erwin-unruh.de/primorig.html

```c++
template <int i> struct D { D(void*); operator int(); };

template <int p, int i> struct is_prime {
  enum { prim = (p%i) && is_prime<(i > 2 ? p : 0), i -1> :: prim };
};

template < int i > struct Prime_print {
  Prime_print<i-1> a;
  enum { prim = is_prime<i, i-1>::prim };
  void f() { D<i> d = prim; }
};

struct is_prime<0,0> { enum {prim=1}; };
struct is_prime<0,1> { enum {prim=1}; };
struct Prime_print<2> { enum {prim = 1}; void f() { D<2> d = prim; } };
#ifndef LAST
#define LAST 10
#endif
main () {
  Prime_print<LAST> a;
}
```

----

### Output

```
P:\HC\D386_O> hc3 i primes.cpp -DLAST=30

MetaWare High C/C++ Compiler R2.6
(c) Copyright 1987-94, MetaWare Incorporated
E "primes.cpp",L16/C63(#416):   prim
|    Type `enum{}´ can´t be converted to txpe `D<2>´ ("primes.cpp",L2/C25).
-- Detected during instantiation of Prime_print<30> at "primes.cpp",L21/C5:
E "primes.cpp",L11/C25(#416):   prim
|    Type `enum{}´ can´t be converted to txpe `D<3>´ ("primes.cpp",L2/C25).
-- Detected during instantiation of Prime_print<30> at "primes.cpp",L21/C5:
E "primes.cpp",L11/C25(#416):   prim
|    Type `enum{}´ can´t be converted to txpe `D<5>´ ("primes.cpp",L2/C25).
-- Detected during instantiation of Prime_print<30> at "primes.cpp",L21/C5:
E "primes.cpp",L11/C25(#416):   prim
|    Type `enum{}´ can´t be converted to txpe `D<7>´ ("primes.cpp",L2/C25).
-- Detected during instantiation of Prime_print<30> at "primes.cpp",L21/C5:
E "primes.cpp",L11/C25(#416):   prim
|    Type `enum{}´ can´t be converted to txpe `D<11>´ ("primes.cpp",L2/C25).
-- Detected during instantiation of Prime_print<30> at "primes.cpp",L21/C5:
E "primes.cpp",L11/C25(#416):   prim
|    Type `enum{}´ can´t be converted to txpe `D<13>´ ("primes.cpp",L2/C25).
-- Detected during instantiation of Prime_print<30> at "primes.cpp",L21/C5:
E "primes.cpp",L11/C25(#416):   prim
|    Type `enum{}´ can´t be converted to txpe `D<17>´ ("primes.cpp",L2/C25).
-- Detected during instantiation of Prime_print<30> at "primes.cpp",L21/C5:
E "primes.cpp",L11/C25(#416):   prim
|    Type `enum{}´ can´t be converted to txpe `D<19>´ ("primes.cpp",L2/C25).
-- Detected during instantiation of Prime_print<30> at "primes.cpp",L21/C5:
E "primes.cpp",L11/C25(#416):   prim
|    Type `enum{}´ can´t be converted to txpe `D<23>´ ("primes.cpp",L2/C25).
-- Detected during instantiation of Prime_print<30> at "primes.cpp",L21/C5:
E "primes.cpp",L11/C25(#416):   prim
|    Type `enum{}´ can´t be converted to txpe `D<29>´ ("primes.cpp",L2/C25).
```

====================

In January 1995, Todd Veldhuizen published an article in the C++ Report that
showcased the first use of Expression Templates.

Note:
Article can be found here: http://www.cs.rpi.edu/~musser/design/blitz/meta-art.html

====================

In 2001, Andrei Alexandrescu published __Modern C++ Design__.
The book made a treatment of C++ metaprogramming by introducing concepts like
Typelists and algorithms on them. The book was describing a library called Loki,
which he made available to the public.

====================

In 2004, David Abrahams and Aleksey Gurtovoy published __C++ Template
Metaprogramming: Concepts, Tools, and Techniques from Boost and Beyond__,
also coined the __MPL Book__. The book made a thorough treatment of
metaprogramming by presenting the __Boost MPL__ library, which contained
several compile-time data structures and algorithms:
- mpl::vector
- mpl::map
- mpl::set
- mpl::list

- mpl::sort
- mpl::reverse
- mpl::push_back
- etc...

The MPL is designed after the STL, with iterators, etc..

----

TODO:
Add examples of using the MPL. The examples should not only be toys, they
should actually be useful.

====================

In 2008, the Boost Fusion library was released by Joel de Guzman, Dan Marsden
and Tobias Schwinger. Fusion emerged out of a need to have a way of storing
and manipulating heterogeneous collections of objects in the Boost Spirit and
Phoenix libraries.

TODO:
Add examples of why heterogeneous collections might be useful in the context
of e.g. Spirit grammars.

----

TODO:
Explain how this is different from MPL:
  MPL focuses on type manipulation only. Ultimately, you'll
  have to map these types to real values to make them useful in the runtime world
  where all the real action takes place.

----

Similarly to MPL, Fusion provides data structures and algorithms to manipulate
them.

- fusion::vector
- fusion::list
- fusion::map

- fusion::reverse
- etc..

TODO:
Show and example of using Fusion as-is.

==============================================================================

## Part 2
## C++11, C++14 and the present

Note:
Discuss libraries like Brigand, Hana and the basics in std
We can spend a good 45 minutes here

==============================================================================

## Part 3
## C++17, C++20 and the future

Note:
Discuss how some language features could make Hana-style more expressive.
Discuss additions to the standard library.
Spend 30 minutes here

==============================================================================

# Thank you

<span class="fragment fade-in">
http://ldionne.com <br>
http://github.com/ldionne <br>
http://github.com/boostorg/hana
</span>


                </script>
                </section>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>
        <!-- Required for the sampler.js plugin -->
        <script src="lib/js/jquery.min.js"></script>

        <script>
            Reveal.initialize({
                slideNumber: true,
                history: true,
                transition: 'slide',

                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: 'plugin/math/math.js', async: true },
                    { src: 'plugin/sampler/sampler.js' }
                ]
            });
        </script>
    </body>
</html>
