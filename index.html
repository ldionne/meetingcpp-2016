<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>C++ metaprogramming: evolution and future directions</title>
        <meta name="author" content="Louis Dionne">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/league.css" id="theme">
        <link rel="stylesheet" href="css/custom.css">

        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>

    <body>
        <div class="reveal">
            <div class="slides">
                <section data-markdown=""
                         data-separator="^====+$"
                         data-separator-vertical="^----+$"
                         data-notes="^Note:">
                <script type="text/template">

## C++ metaprogramming: evolution and future directions
### Louis Dionne, Meeting C++ 2016

==============================================================================

## Part 1
## A bit of history

Note:
Discuss the beginnings of metaprogramming, Loki, MPL and Fusion
Spend 30 minutes here

====================

### It all started with templates

```c++
template <typename T>
struct vector { /* ... */ };

int main() {
  vector<int> ints = {1, 2, 3};
  vector<string> strings = {"foo", "bar", "baz"};
}
```

Note:
Goal: generic containers and algorithms for the standard library

----

### The Committee suspected templates were hiding something more powerful

----

### It wasn't clear until someone came up with a very special program

====================

### March 1994, San Diego meeting
### Erwin Unruh comes up with this:

```c++
template <int i> struct D { D(void*); operator int(); };

template <int p, int i> struct is_prime {
  enum { prim = (p%i) && is_prime<(i > 2 ? p : 0), i -1> :: prim };
};

template < int i > struct Prime_print {
  Prime_print<i-1> a;
  enum { prim = is_prime<i, i-1>::prim };
  void f() { D<i> d = prim; }
};

struct is_prime<0,0> { enum {prim=1}; };
struct is_prime<0,1> { enum {prim=1}; };
struct Prime_print<2> { enum {prim = 1}; void f() { D<2> d = prim; } };
#ifndef LAST
#define LAST 10
#endif
main () {
  Prime_print<LAST> a;
}
```

(source: http://www.erwin-unruh.de/primorig.html)

----

### What does this program do?

----

### It prints prime numbers at compile-time

```
P:\HC\D386_O> hc3 i primes.cpp -DLAST=30

MetaWare High C/C++ Compiler R2.6
(c) Copyright 1987-94, MetaWare Incorporated
E "primes.cpp",L16/C63(#416):   prim
|    Type `enum{}´ can´t be converted to txpe `D<2>´ [...]
-- Detected during instantiation of Prime_print<30> [...]
E "primes.cpp",L11/C25(#416):   prim
|    Type `enum{}´ can´t be converted to txpe `D<3>´ [...]
-- Detected during instantiation of Prime_print<30> [...]
E "primes.cpp",L11/C25(#416):   prim
|    Type `enum{}´ can´t be converted to txpe `D<5>´ [...]
-- Detected during instantiation of Prime_print<30> [...]
E "primes.cpp",L11/C25(#416):   prim
|    Type `enum{}´ can´t be converted to txpe `D<7>´ [...]
-- Detected during instantiation of Prime_print<30> [...]
E "primes.cpp",L11/C25(#416):   prim
|    Type `enum{}´ can´t be converted to txpe `D<11>´ [...]
-- Detected during instantiation of Prime_print<30> [...]
E "primes.cpp",L11/C25(#416):   prim
|    Type `enum{}´ can´t be converted to txpe `D<13>´ [...]

[...]
```

----

### This proves that templates can be used to perform arbitrary compile-time computations


Note:
In other words, C++ contains a Turing-complete sub-language that can be
executed inside the compiler. The result of a program written in that
language is another C++ program, which in this case is invalid and thus
causes the compiler to give away selected parts of its output.

----

### But we still lack concrete and/or creative applications of templates outside the STL

====================

### The C++ Report, January 1995
### Todd Veldhuizen publishes [an article](http://www.cs.rpi.edu/~musser/design/blitz/meta-art.html) on Expression Templates

----

### But what are expression templates?

```c++
template <typename T>
struct Matrix { /* ... */ };

template <typename E1, typename E2>
class Sum {
  E1 const& left_;
  E2 const& right_;

public:
  auto operator[](std::pair<std::size_t, std::size_t> index) const
  { return left_[index] + right_[index]; }
};

template <typename Left, typename Right>
Sum<Left, Right> operator+(Left const& left, Right const& right)
{ return {left, right}; }

int main() {
  Matrix<int> m1 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
  Matrix<int> m2 = {{9, 8, 7}, {6, 5, 4}, {3, 2, 1}};
  auto sum = m1 + m2; // Nothing done yet!
  auto x = sum[{1, 2}]; // The work is done here
}
```

Note:
In practice, we really want to recognize patterns and optimize them with
hand-written kernels, so the above is not really useful as-is.

====================

### Fast forward to 2001
### Andrei Alexandrescu publishes Modern C++ Design

----

### Introduces the [Loki](http://loki-lib.sourceforge.net) library, which includes `Typelist`

```c++
template <class T, class U>
struct Typelist {
   typedef T Head;
   typedef U Tail;
};

using Types = LOKI_TYPELIST_4(int, char, float, void);
static_assert(std::is_same<
    Loki::TL::TypeAt<Types, 2>::Result,
    float
>::value, "");
```

----

### Several algorithms on `Typelist` are provided

```c++
using Types = LOKI_TYPELIST_6(int, char, float, char, void, float);

using NoChar = Loki::TL::EraseAll<Types, char>::Result;
using Uniqued = Loki::TL::NoDuplicates<Types>::Result;
using Reversed = Loki::TL::Reverse<Types>::Result;
// etc...
```

----

### The notion of compile-time algorithms and data structures starts to emerge

====================

### 2004
### D. Abrahams and A. Gurtovoy publish the MPL book

<span class="fragment">
The book is actually called <br/>_C++ Template Metaprogramming: Concepts, Tools,
and Techniques from Boost and Beyond_
</span>

----

### It makes a thorough treatment of metaprogramming through the Boost MPL library

----

### The library contains several meta data structures

- `boost::mpl::vector`
- `boost::mpl::list`
- `boost::mpl::map`
- `boost::mpl::set`
- `boost::mpl::string`

----

### It also provides several generic algorithms working on meta-iterators, like the STL

- `boost::mpl::sort`
- `boost::mpl::reverse`
- `boost::mpl::accumulate`
- `boost::mpl::transform`
- `boost::mpl::partition`
- etc...

----

TODO:
Add examples of using the MPL. The examples should not only be toys, they
should actually be useful.

====================

In 2008, the Boost Fusion library was released by Joel de Guzman, Dan Marsden
and Tobias Schwinger. Fusion emerged out of a need to have a way of storing
and manipulating heterogeneous collections of objects in the Boost Spirit and
Phoenix libraries.

TODO:
Add examples of why heterogeneous collections might be useful in the context
of e.g. Spirit grammars.

----

TODO:
Explain how this is different from MPL:
  MPL focuses on type manipulation only. Ultimately, you'll
  have to map these types to real values to make them useful in the runtime world
  where all the real action takes place.

----

Similarly to MPL, Fusion provides data structures and algorithms to manipulate
them.

- fusion::vector
- fusion::list
- fusion::map

- fusion::reverse
- etc..

TODO:
Show and example of using Fusion as-is.

====================

TODO:
Mention "Instantiations must go"

==============================================================================

## Part 2
## C++11, C++14, and the present

Note:
Discuss libraries like Brigand, Hana and the basics in std
We can spend a good 45 minutes here

====================

C++11 introduced many new features that we expected would allow better
compile-time performance, better error messages and more expressiveness.

- Variadic templates
- ???

====================

So, in 2012, I started working on MPL11, a C++11-aware metaprogramming library.
It started out as a modernized MPL (same design), but ended up diverging
significantly. MPL uses iterators like in the STL, but iterators are not
the best abstraction for a purely functional and compile-time language.

Since then, others have undertaken similar projects, the most successful
probably being Brigand

TODO:
Show examples, discuss compile-time performance, etc..

====================

Eventually, in 2013, I realized that we could leverage C++14 features to take
this to the next level. I stopped working on MPL11 and started working on Hana.
What was the insight?

TODO:
Explain how we represent types as values.
Explain how this allows us to do what Fusion did in addition to what MPL did.
Show examples of using Hana, and discuss compile-time + runtime performance.

====================

In the meantime, some things have made it into the Standard:
- type_traits (C++11)
- tuple (C++11)
- enable_if (C++11)
- integer_sequence (C++14)

- fold expressions (C++17)
- if constexpr (C++17)
- logical type traits (C++17)
- void_t (C++17)
- _v variable templates for type traits (C++17)

Unfortunately, we're lacking a __unified__ view of how these features are to
work together. The result is that they _don't_ work together seamlessly.

==============================================================================

## Part 3
## C++17, C++20 and the future

Note:
Discuss how some language features could make Hana-style more expressive.
Discuss additions to the standard library.
Spend 30 minutes here

----

## Metaprogramming by design, not by accident

==============================================================================

# Thank you

<span class="fragment fade-in">
http://ldionne.com <br>
http://github.com/ldionne <br>
http://github.com/boostorg/hana
</span>


                </script>
                </section>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>
        <!-- Required for the sampler.js plugin -->
        <script src="lib/js/jquery.min.js"></script>

        <script>
            Reveal.initialize({
                slideNumber: true,
                history: true,
                transition: 'none',

                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: 'plugin/math/math.js', async: true },
                    { src: 'plugin/sampler/sampler.js' }
                ]
            });
        </script>
    </body>
</html>
